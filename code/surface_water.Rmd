---
title: "Surface Water"
output:
  html_document: default
  toc: true
  toc_depth: 3 
---

# The Prompt 

Background: The attached Excel file (Dataset_C) contains analytical chemistry data from a variety of surface water stations. 
 
Given the attached dataset:

* Develop a tool for plotting time series by station and analyte.

* Symbolize data by season.

* Add a horizontal line for the mean concentration to each plot.

* Which analytes have the most seasonal variability?  What tools/approach did you use?

* Produce a pdf of your plots.


# First Forays and Data Explorations

Before creating the final products, I've done some preparation and basic exploration, generally scoping out the data set, and preparing it for downstream analysis. 

```{r, setup, include=TRUE, warning=F, message=F}
rm(list=ls()) # Clear working environment

library("MapSuite") #Self-written library, has many common libs as dependencies
library("hexbin") # For the hex-bin plots

# Read in surface water observations as data.table sw
  sw<-fread("/Users/stubbsrw/Documents/git_code/stubbs_repo/fe_problems/data/Dataset_C.csv")

# Parse out date information from character date column
  sw[,index:=seq(1:nrow(sw))]
  sw[,Month:=as.numeric(strsplit(SampleDate,"/")[[1]][1]),by=index] 
  sw[,Day:=as.numeric(strsplit(SampleDate,"/")[[1]][2]),by=index]
  sw[,Year:=as.numeric(strsplit(SampleDate,"/")[[1]][3]),by=index]
  sw[,Date:=as.IDate(paste0((2000+Year),"-",Month,"-",Day))] # Create formal column of integer-date

# For each analyte, discover the minimum date, and generate a month index from that date:
  sw[,year_index:=Year-min(Year,na.rm=T),by=StandardAnalyte]
  sw[,year_min:=min(Year,na.rm=T),by=StandardAnalyte] # First sample year, calculated by each analyte
  sw[,month_index:=12*(Year-year_min) + Month] # Number of months from the start of the samples

# Add variables on mean concentration for each analyte by site and globally/for all samples
  sw[,mean_concentration_analyte_station:=mean(StandardResult,na.rm=T),by=list(StationName,StandardAnalyte)]
  sw[,mean_concentration_analyte:=mean(StandardResult,na.rm=T),by=StandardAnalyte]
```

## Assign seasons to different months

In order to symbolize by season, you first need to define what data points are in each season. For now, I'm lumping observations into seasons by month. You could do this a fancier way if you wanted, based on cut points of the equinoxes; for now, we'll just go with month-by-month approximations. I'm also assuming that this is in the Northern hemisphere...


```{r}
sw[Month %in% c(12,1,2), Season:='Winter']
sw[Month %in% c(3,4,5), Season:='Spring']
sw[Month %in% c(6,7,8), Season:='Summer']
sw[Month %in% c(9,10,11), Season:='Fall']
sw[,Month_String:=month.abb[Month]]
sw[,log_obs:=log(StandardResult)] # Just in case a log-transform would be more informative, although NaNs will exist where the observation is negative
sw[,Season:=factor(Season, levels = c("Winter","Spring","Summer","Fall"))] # Defining Season as a factor variable
```

### Plotting Temperature over the full time series

```{r}
a<-"Temperature" #Picking this one since I have the best sense of what it "should" or "could" be per season

# Make a subset data set with only the analyte you are interested in
analyte<-sw[StandardAnalyte==a]
mean_observation<-mean(analyte$StandardResult)

# Plotting using the HexBin Frequency graphics, where the number of stations with an observation in that category is essentially heat-mapped
ggplot(analyte, aes(x=Date, y=StandardResult)) + 
  geom_hex() + 
  xlab("Observations Over Time, All Stations") + 
  scale_x_date(labels = function(x) format(x, "%b-%y")) + 
  ylab(analyte$StandardUnit[1]) + 
  ggtitle(paste0(a)) + theme_bw() + 
  scale_fill_gradientn(colors=wpal("berries")) +
  guides(fill=guide_colourbar(title="N Stations", title.position="top", barheight=10, barwidth=1,
                              label=TRUE, ticks=FALSE, direction="vertical")) 
```

Let's try pooling observations across stations and also years, to get a rough sense of seasonality from a graphical persepective: 
```{r}
# Plotting by Month, for all years, all stations 
months_in_order<-c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")

# Non-Transformed
ggplot(analyte, aes(x= Month, y=log_obs)) + geom_hex() + 
  xlab("Observations in Each Month, All Years, All Stations") + 
  scale_x_continuous(limits=c(1,12),breaks=seq(1,12), labels=months_in_order) +
  ylab(analyte$StandardUnit[1]) + 
  ggtitle(paste0(a)) + theme_bw() + 
  scale_fill_gradientn(colors=wpal("berries")) +
  guides(fill=guide_colourbar(title="N Stations", title.position="top", barheight=10, barwidth=1,
                              label=TRUE, ticks=FALSE, direction="vertical")) 
```

# Plotting a full time series for one station, one analyte

Below is code to graph a subset of the data (one station's measurements for a specific analyte), with the data symbolized by season (in this case, using color to clarify which season the data point was taken in).

```{r}
a<-"Temperature"
s<-"FE-4023" # arbitrary station to test things out on; note that the data set analyte is already set to be Temperature.

# Define a color pallette for the factor variable, Season
SeasonColors<-wpal("foliage",noblack=T,n=4)
names(SeasonColors) <- c("Winter","Spring","Summer","Fall")

ggplot(sw[StandardAnalyte==a & StationName==s], 
  aes(x= Date, y=StandardResult, color=Season)) + geom_point(size=4) + 
  xlab("Date of Sample") + 
  scale_x_date(labels = function(x) format(x, "%b-%y")) + 
  ylab(analyte$StandardUnit[1]) + 
  ggtitle(paste0(a), subtitle=paste0("Station ",s)) + theme_bw()  + 
  scale_colour_manual(name = "Seasons",values = SeasonColors, drop=F) +
  geom_hline(yintercept = sw[StandardAnalyte==a & StationName==s]$mean_concentration_analyte_station[1]) + 
  annotate("text", min(analyte$Date), 
           sw[StandardAnalyte==a & StationName==s]$mean_concentration_analyte_station[1], 
           vjust = -1, label = "Mean")

```

OK, good enough to iterate over; we can add those plots to PDF dashboards for each of the analytes later on.

# Quantifying Seasonality

Unfortunately, there aren't very many data points per station within this data set, and the time period of observation only lasts a few years' time. This makes disentangling variation in observations for each site difficult-- is the change in observed data measurement error, a product of seasonal variation, inter-annual variation, random noise, or the effect of a recent event, or influence of a covariate? 

Without knowing the spatial location of any of the stations, I assumed that the stations would be nearby one another, and subject to (at least roughly) the same weather and insolation patterns--- if these stations were far apart, it would be even more difficult to measure the "seasonal component" of each analyte, since the magnitude of seasonal changes could be subject to variables such as latitude and elevation. 

Given these constraints, a few different strategies came to mind. For each of them, I tested the method on Temperature, since the right strategy would presumably show a seasonal effect for this analyte. 

## Method 1: 

There is some discussion of the number of knots that are appropriate for seasonal land (not water) surface temperature changes in this paper here: http://www.mdpi.com/2072-4292/9/12/1254/pdf; however, it is discussed that the ideal number of knots for their model to represent seasonality (8) may not be appropriate for other applications. 


## Fit GAMM with knots for each season and year

Another possible approach is to fit a general additive mixed model, where the long-term time trend and the short-term, periodic annual trends are conceptualized by cubic splines. 

```{r}
# Pulling from https://www.fromthebottomoftheheap.net/2014/05/09/modelling-seasonal-data-with-gam/
# 1 knot every 6 months, 1 knot for each year of data?
m0 <- mgcv::gamm(StandardResult ~ s(Month, bs = "cc", k = 6) + s(month_index, k = 3) + as.factor(StationName), data = analyte)

plot(m0$gam, scale = 0, main = "GAMM fit", xlab = "Month", ylab = paste0(a," Seasonal Effect"))

```

Let's try a linear model with a sin and cosine function

```{r}
mod <- lm(log_obs  ~ sin(2*pi*(month_index/12))+cos(2*pi*(month_index/12))+StationName,data=analyte)
summary(mod)

plot(log_obs~month_index,data=analyte)
plot(analyte$month_index,mod$fitted.values)
```
## Linear Model with 

```{r}
mod <- lm(StandardResult  ~ sin(2*pi*(month_index/12))+cos(2*pi*(month_index/12))+StationName+Year,data=analyte)
summary(mod)

plot(StandardResult~month_index,data=analyte)
lines(mod$fitted.values,analyte$month_index,col=2)

analyte[,fitted:=mod$fitted.values]
```



## Generate PDF of results for each Analyte


```{r}
for ( a in unique(sw$StandardAnalyte)){
  analyte<-sw[StandardAnalyte==a] 
pdf(paste0("/Users/stubbsrw/Documents/git_code/stubbs_repo/fe_problems/results/surface_temperature/",a,".pdf"))

  # Generate plot for each Analyte over time, for each station. 
  for (s in unique(sw$StationName)){
  
    p<-ggplot(sw[StandardAnalyte==a & StationName==s], 
        aes(x= Date, y=StandardResult, color=Season)) + geom_point(size=4) + 
        xlab("Date of Sample") + 
        scale_x_date(labels = function(x) format(x, "%b-%y")) + 
        ylab(analyte$StandardUnit[1]) + 
        ggtitle(paste0(a), subtitle=paste0("Station ",s)) + theme_bw()  + 
        scale_colour_manual(name = "Seasons",values = SeasonColors, drop=F) +
        geom_hline(yintercept = sw[StandardAnalyte==a & StationName==s]$mean_concentration_analyte_station[1]) + 
        annotate("text", min(analyte$Date), 
                 sw[StandardAnalyte==a & StationName==s]$mean_concentration_analyte_station[1], 
                 vjust = -1, label = "Mean")
    
    print(p) # Print it to the PDF
  }
  dev.off() # Close PDF for each 
}
```